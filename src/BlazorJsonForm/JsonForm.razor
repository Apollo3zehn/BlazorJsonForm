@using Microsoft.AspNetCore.Components.Rendering
@using NJsonSchema
@using System.Text.Json.Nodes
@using System.Text.Json
@using System.Runtime.CompilerServices
@using System.Numerics

<div style="display: flex; flex-direction: column;">
    @_renderFragement
</div>

@code {

    private RenderFragment _renderFragement = default!;

    /// <summary>
    /// The JSON schema to create a form for.
    /// </summary>
    [Parameter]
    public JsonSchema Schema { get; set; } = default!;

    /// <summary>
    /// The JSON data store.
    /// </summary>
    [Parameter]
    public JsonNode? Data { get; set; } = default!;

    /// <summary>
    /// The JSON data store event callback.
    /// </summary>
    [Parameter]
    public EventCallback<JsonNode?> DataChanged { get; set; }

    protected override void OnInitialized()
    {
        _renderFragement = builder =>
        {
            var oldData = Data;

            Data = Render(
                "Rocket settings", 
                Schema,
                Data,
                setValue: default,
                builder,
                isTopLevel: true
            );

            if (JsonSerializer.Serialize(oldData) != JsonSerializer.Serialize(Data) && 
                DataChanged.HasDelegate)
            {
                DataChanged.InvokeAsync(Data);
            }
        };
    }

    private string RenderWithDisposableReturnValue(
        string label, 
        JsonSchema schema, 
        JsonNode? data,
        Action<JsonNode?>? setValue,
        RenderTreeBuilder builder, 
        bool isTopLevel
    )
    {
        Render(label, schema, data, setValue, builder, isTopLevel);
        return string.Empty;
    }

    private JsonNode? Render(
        string label, 
        JsonSchema schema, 
        JsonNode? data,
        Action<JsonNode?>? setValue,
        RenderTreeBuilder builder, 
        bool isTopLevel
    )
    {
        var __builder = builder;
        var isNullable = schema.Type.HasFlag(JsonObjectType.Null);

        switch (schema.Type)
        {
            case JsonObjectType.Integer:
            case JsonObjectType.Integer | JsonObjectType.Null:

                if (schema.Enumeration.Any())
                {
                    var enumType = schema.Enumeration.ElementAt(0)!.GetType();

                    if (enumType == typeof(byte))
                        data = RenderEnum<byte>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(sbyte))
                        data = RenderEnum<sbyte>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(ushort))
                        data = RenderEnum<ushort>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(short))
                        data = RenderEnum<short>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(uint))
                        data = RenderEnum<uint>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(int))
                        data = RenderEnum<int>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(ulong))
                        data = RenderEnum<ulong>(label, schema, (JsonValue?)data, setValue, builder);

                    else if (enumType == typeof(long))
                        data = RenderEnum<long>(label, schema, (JsonValue?)data, setValue, builder);

                    else
                        throw new Exception($"Unexpected enum type {enumType.FullName}");
                }

                else
                {
                    data = schema.Format switch
                    {
                        "byte" => RenderNumeric<byte>(label, isNullable, schema, (JsonValue?)data, setValue, builder),
                        "uint64" => RenderNumeric<ulong>(label, isNullable, schema, (JsonValue?)data, setValue, builder),
                        "int64" => RenderNumeric<long>(label, isNullable, schema, (JsonValue?)data, setValue, builder),
                        _ => RenderNumeric<int>(label, isNullable, schema, (JsonValue?)data, setValue, builder)
                    };
                }

                break;

            case JsonObjectType.Number:
            case JsonObjectType.Number | JsonObjectType.Null:

                data = schema.Format switch
                {
                    "float" => RenderNumeric<float>(label, isNullable, schema, (JsonValue?)data, setValue, builder),
                    "double" => RenderNumeric<double>(label, isNullable, schema, (JsonValue?)data, setValue, builder),
                    _ => throw new Exception($"schema.Format {schema.Format} is not (yet) supported")
                };

                break;

            case JsonObjectType.Boolean:
            case JsonObjectType.Boolean | JsonObjectType.Null:

                if (isNullable)
                {
                    <MudCheckBox
                        Label="@label"
                        Color="@Color.Primary"
                        TriState="true"
                        @bind-Value:get="data is null ? default(bool?) : data.GetValue<bool>()"
                        @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))" />
                }

                else
                {
                    if (data is null)
                        data = false;

                    <MudSwitch 
                        Label="@label"
                        Color="Color.Primary"
                        @bind-Value:get="data.GetValue<bool>()"
                        @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))" />
                }

                break;

            case JsonObjectType.String:
            case JsonObjectType.String | JsonObjectType.Null:

                if (isNullable)
                {
                    <MudTextField 
                        Label="@label"
                        MaxLength="schema.MaxLength is null ? int.MaxValue : (int)schema.MaxLength"
                        Counter="schema.MaxLength is null ? 0 : schema.MaxLength"
                        Clearable="true"
                        OnClearButtonClick="() => setValue?.Invoke(default)"
                        @bind-Value:get="data is null ? null : data.GetValue<string>()"
                        @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))" />
                }

                else
                {
                    if (data is null)
                        data = string.Empty;

                    <MudTextField 
                        Label="@label"
                        MaxLength="schema.MaxLength is null ? int.MaxValue : (int)schema.MaxLength"
                        Counter="schema.MaxLength is null ? 0 : schema.MaxLength"
                        @bind-Value:get="data.GetValue<string>()"
                        @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))" />
                }

                break;

            case JsonObjectType.Object:

                data = RenderObject(
                    label, 
                    schema.ActualProperties,
                    (JsonObject?)data,
                    builder, 
                    isTopLevel
                );

                break;

            case JsonObjectType.None:

                if (schema.OneOf.Count == 1)
                {
                    data = Render(
                        label,
                        schema.ActualSchema,
                        data,
                        setValue,
                        builder,
                        isTopLevel
                    );
                }

                else
                {
                    throw new Exception("schema.OneOf.Count != 1 is not (yet) supported");
                }

                break;

            case JsonObjectType.Array:

                if (data is null)
                    data = new JsonArray();

                RenderArray(
                    label,
                    schema,
                    (JsonArray)data,
                    builder,
                    isTopLevel
                );

                break;

            default:
                throw new Exception($"{schema.Type} is not (yet) supported");
        }

        return data;
    }

    private JsonObject RenderObject(
        string? title,
        IReadOnlyDictionary<string, JsonSchemaProperty> properties, 
        JsonObject? data,
        RenderTreeBuilder builder,
        bool isTopLevel)
    {
        var __builder = builder;

        if (data is null)
            data = new JsonObject();

        var margin = isTopLevel ? "" : " margin-left: 1rem; margin-top: 1rem; margin-bottom: 1rem;";

        <div style="display: flex; flex-direction: column; gap: 1rem;@margin">

            <MudText Typo="Typo.h6">
                @title
            </MudText>

            @foreach (var entry in properties)
            {
                var (name, propertySchema) = entry;
                var label = propertySchema.Description ?? name;

                data.TryGetPropertyValue(name, out var propertyData);

                data[name] = Render(
                    label, 
                    propertySchema,
                    propertyData,
                    setValue: value =>
                    {
                        data[name] = value;

                        if (DataChanged.HasDelegate)
                            DataChanged.InvokeAsync(Data);
                    },
                    builder,
                    isTopLevel: false
                );
            }

        </div>

        return data;
    }

    private JsonValue? RenderNumeric<T>(
        string label,
        bool isNullable,
        JsonSchema schema,
        JsonValue? data,
        Action<JsonNode?>? setValue,
        RenderTreeBuilder builder) where T : struct, IMinMaxValue<T>, INumber<T>, IBitwiseOperators<T, T, T>
    {
        var __builder = builder;

        if (isNullable)
        {
            <MudNumericField
                T="Nullable<T>"
                Label="@label"
                Min="schema.Minimum.HasValue ? T.CreateChecked(schema.Minimum.Value) : T.MinValue"
                Max="schema.Maximum.HasValue ? T.CreateChecked(schema.Maximum.Value) : T.MaxValue"
                @bind-Value:get="data is null ? default(T?) : data.GetValue<T>()"
                @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))" />
        }

        else
        {
            if (data is null)
                data = JsonValue.Create(T.Zero);

            <MudNumericField 
                Label="@label"
                Min="schema.Minimum.HasValue ? T.CreateChecked(schema.Minimum.Value) : T.MinValue"
                Max="schema.Maximum.HasValue ? T.CreateChecked(schema.Maximum.Value) : T.MaxValue"
                @bind-Value:get="data!.GetValue<T>()"
                @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))" />
        }

        return data;
    }

    private JsonValue RenderEnum<T>(
        string label,
        JsonSchema schema,
        JsonValue? data,
        Action<JsonNode?>? setValue,
        RenderTreeBuilder builder) where T : INumber<T>, IBitwiseOperators<T, T, T>
    {
        var __builder = builder;

        if (data is null)
            data = JsonValue.Create(T.Zero);

        var valueNamePairs = schema
            .Enumeration
            .Cast<T>()
            .Zip(schema.EnumerationNames)
            .ToList();

        <MudSelect 
            Label="@label"
            MultiSelection="schema.IsFlagEnumerable"
            ToStringFunc="item => valueNamePairs.First(x => x.First is not null && x.First.Equals(item)).Second"
            @bind-Value:get="data!.GetValue<T>()"
            @bind-Value:set="value => setValue?.Invoke(JsonValue.Create(value))"
            @bind-SelectedValues:get="FromFlags(data.GetValue<T>())"
            @bind-SelectedValues:set="value => setValue?.Invoke(JsonValue.Create(ToFlags(value)))">

            @foreach (var valueNamePair in valueNamePairs)
            {
                <MudSelectItem Value="valueNamePair.First" />
            }

        </MudSelect>

        return data;
    }

    private void RenderArray(
        string? title,
        JsonSchema schema,
        JsonArray data,
        RenderTreeBuilder builder,
        bool isTopLevel)
    {
        if (schema.Item is null)
            throw new Exception("schema.Item is null");

        var __builder = builder;
        var margin = isTopLevel ? "" : " margin-left: 1rem; margin-top: 1rem; margin-bottom: 1rem;";

        <div style="display: flex; flex-direction: column; gap: 1rem;@margin">

            <MudText Typo="Typo.h6">
                @title
            </MudText>

            @for (int i = 0; i < data.Count; i++)
            {
                var i_captured = i;

                <div style="display: flex;">
                    <div style="flex: 1;">
                        @RenderWithDisposableReturnValue(
                            "#" + (i_captured + 1),
                            schema.Item.ActualSchema,
                            data[i_captured],
                            setValue: value =>
                            {
                                data[i_captured] = value;

                                if (DataChanged.HasDelegate)
                                    DataChanged.InvokeAsync(Data);
                            },
                            builder,
                            isTopLevel: false
                        )
                    </div>

                    <div>
                        <MudMenu Size="Size.Small" Icon="@Icons.Material.Filled.MoreVert">

                            @if (i_captured != 0)
                            {
                                <MudMenuItem
                                    OnClick="() => MoveUp(data, i_captured)"
                                    Icon="@Icons.Material.Filled.ArrowUpward">
                                    Move up
                                </MudMenuItem>
                            }

                            @if (i_captured != data.Count - 1)
                            {
                                <MudMenuItem
                                    OnClick="() => MoveDown(data, i_captured)"
                                    Icon="@Icons.Material.Filled.ArrowDownward">
                                    Move down
                                </MudMenuItem>
                            }
                            
                            <MudMenuItem
                                OnClick="() => Delete(data, i_captured)"
                                Icon="@Icons.Material.Filled.Delete">
                                Delete
                            </MudMenuItem>
                        </MudMenu>
                    </div>
                </div>
            }

            <div style="margin-left: auto; margin-right: auto;">
                <MudIconButton 
                    Icon="@Icons.Material.Filled.Add"
                    OnClick="() => 
                    {
                        var item = Render(
                            string.Empty,
                            schema.Item.ActualSchema,
                            data: default,
                            setValue: default,
                            /* TODO the builder is useless here */
                            builder: new RenderTreeBuilder(),
                            isTopLevel: false
                        );

                        data.Add(item);

                        if (DataChanged.HasDelegate)
                            DataChanged.InvokeAsync(Data);
                    }" />

            </div>

        </div>
    }

    @* private JsonValue? SetValue<T>(T? value, JsonValue? data)
    {
        if (value is null)
            return null;

        else if (data is null)
            return JsonValue.Create(value);

        else
            data.ReplaceWith(value);

        if (DataChanged.HasDelegate)
            DataChanged.InvokeAsync(Data);

        return data;
    } *@

    private IEnumerable<T> FromFlags<T>(T value) where T : INumber<T>, IBitwiseOperators<T, T, T>
    {
        var result = new List<T>();
        var two = T.One + T.One;

        for (int i = 0; i < Unsafe.SizeOf<T>() * 8; i++)
        {
            // this mimics the bit-shift operator (1 << i) as no generic math equivalent was found
            var shiftedOne = T.One;

            for (int j = 0; j < i; j++)
            {
                shiftedOne = shiftedOne * two;
            }

            // now continue as normal
            var isBitSet = (value & shiftedOne) > T.Zero;

            if (isBitSet)
                result.Add(shiftedOne);
        }

        return result;
    }

    // Generic math: sum
    // https://stackoverflow.com/a/73906555
    private T ToFlags<T>(IEnumerable<T> numbers) where T : INumber<T>
    {
        return numbers.Aggregate(T.Zero, (sum, value) => sum + T.CreateChecked(value));
    }

    private void MoveUp(JsonArray data, int position)
    {
        var item = data[position];

        data.RemoveAt(position);
        data.Insert(position - 1, item);
    }

    private void MoveDown(JsonArray data, int position)
    {
        var item = data[position];

        data.RemoveAt(position);
        data.Insert(position + 1, item);
    }

    private void Delete(JsonArray data, int position)
    {
        data.RemoveAt(position);
    }
}